!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("@angular/common"),require("@angular/forms"),require("@ng-bootstrap/ng-bootstrap")):"function"==typeof define&&define.amd?define("ngx-tags-input",["exports","@angular/core","@angular/common","@angular/forms","@ng-bootstrap/ng-bootstrap"],t):t(e["ngx-tags-input"]={},e.ng.core,e.ng.common,e.ng.forms,e.ngBootstrap)}(this,function(e,t,n,a,o){"use strict";var i=function(){function e(){}return e.decorators=[{type:t.Injectable,args:[{providedIn:"root"}]}],e.ctorParameters=function(){return[]},e.ngInjectableDef=t.defineInjectable({factory:function(){return new e},token:e,providedIn:"root"}),e}(),s=function(){},p={provide:a.NG_VALUE_ACCESSOR,useExisting:t.forwardRef(function(){return r}),multi:!0},r=function(){function e(){this.selected="",this.tags=[],this.onTouchedCallback=s,this.onChangeCallback=s,this.type="light",this.removeLastOnBackspace=!1,this.canDeleteTags=!0,this.placeholder="",this.options=null,this.displayField="displayValue",this.minLengthBeforeOptions=1,this.scrollableOptions=!1,this.scrollableOptionsInView=5,this.onTagsChanged=new t.EventEmitter,this.onMaxTagsReached=new t.EventEmitter,this.onNoOptionsMatch=new t.EventEmitter}return e.prototype.ngOnInit=function(){},e.prototype.getPlaceHolder=function(){return this.tags&&0<this.tags.length?"":this.placeholder},e.prototype.tagsChanged=function(e,t){this.onChangeCallback(this.tags),this.onTagsChanged.emit({change:e,tag:t}),this.maximumOfTagsReached()&&this.onMaxTagsReached.emit()},e.prototype.removeLastTag=function(e){this.removeLastOnBackspace&&this.tags.length&&""===e.value&&this.removeTag(this.tags[this.tags.length-1])},e.prototype.addTag=function(e){var t;if(""!==e.value.trim()){var n=((t={})[this.displayField]=e.value,t);this.addPredefinedTag(n)}e.value=""},e.prototype.addPredefinedTag=function(e){this.maximumOfTagsReached()||(this.tags.push(e),this.tagsChanged("add",e))},e.prototype.removeTag=function(t){this.isDeleteable(t)&&(this.tags=this.tags.filter(function(e){return t!==e}),this.tagsChanged("remove",t))},e.prototype.maximumOfTagsReached=function(){return"undefined"!=typeof this.maxTags&&this.tags.length>=this.maxTags},e.prototype.isDeleteable=function(e){return!("undefined"!=typeof e.deleteable&&!e.deleteable)&&this.canDeleteTags},e.prototype.typeaheadOnSelect=function(e){var t;"string"==typeof e.item?this.addPredefinedTag(((t={})[this.displayField]=e.value,t)):this.addPredefinedTag(e.item),this.selected=""},e.prototype.typeaheadOnNoMatch=function(e){"undefined"!=typeof this.onNoOptionsMatch&&this.onNoOptionsMatch.emit(e)},e.prototype.writeValue=function(e){e!==this.tags&&(this.tags=e)},e.prototype.registerOnChange=function(e){this.onChangeCallback=e},e.prototype.registerOnTouched=function(e){this.onTouchedCallback=e},e.decorators=[{type:t.Component,args:[{selector:"tags-input",template:'<div class="tags-input form-group">\n    <div class="form-control">\n        <span class="tags-input__tag badge" ngClass="badge-{{ type }}" *ngFor="let tag of tags">\n            {{tag[displayField]}}\n            <span *ngIf="isDeleteable(tag)" \n                role="button" \n                class="tags-input__tag-remove-btn" \n                (click)="removeTag(tag)" \n                (touch)="removeTag(tag)">\n                <span aria-hidden="true">&times;</span>\n                <span class="sr-only">Close</span>\n            </span>\n        </span>\n        <input\n            *ngIf="options === null" \n            class="tags-input__input-field" \n            type="text" \n            placeholder="{{ getPlaceHolder() }}"\n            name="tags"\n            (keyup.enter)="addTag(tagInput)" (keydown.backspace)="removeLastTag(tagInput)"\n            [disabled]="maximumOfTagsReached()"\n            [hidden]="maximumOfTagsReached()"\n            #tagInput />\n        <input\n            *ngIf="options !== null" \n            class="tags-input__input-field" \n            type="text" \n            placeholder="{{ getPlaceHolder() }}"\n            name="tags"\n            (keydown.backspace)="removeLastTag(tagInput)"\n            [(ngModel)]="selected" \n           \n            [hidden]="maximumOfTagsReached()"\n            #tagInput />\n    </div>\n</div>\n\x3c!--\n     [typeahead]="options"\n            [typeaheadOptionField]="displayField"\n            (typeaheadOnSelect)="typeaheadOnSelect($event)"\n            (typeaheadNoResults)="typeaheadOnNoMatch($event)"\n            [typeaheadMinLength]="minLengthBeforeOptions"\n            [typeaheadScrollable]="scrollableOptions"\n            [typeaheadOptionsInScrollableView]="scrollableOptionsInView"\n            [disabled]="maximumOfTagsReached()"\n--\x3e',providers:[p],styles:[":host{overflow:auto;white-space:nowrap}.tags-input{align-items:center;display:flex;flex-wrap:wrap}.tags-input__tag{display:inline-block;margin-bottom:2px;margin-right:5px;padding-right:.3em;font-size:110%;font-weight:initial;border:1px solid grey}.tags-input__tag-remove-btn{cursor:pointer;display:inline-block;font-size:12px;margin:-3px 0 0 3px;padding:0;vertical-align:top}.tags-input__input-field{border:none;flex-grow:1;outline:0}"]}]}],e.ctorParameters=function(){return[]},e.propDecorators={maxTags:[{type:t.Input}],type:[{type:t.Input}],removeLastOnBackspace:[{type:t.Input}],canDeleteTags:[{type:t.Input}],placeholder:[{type:t.Input}],options:[{type:t.Input}],displayField:[{type:t.Input}],minLengthBeforeOptions:[{type:t.Input}],scrollableOptions:[{type:t.Input}],scrollableOptionsInView:[{type:t.Input}],onTagsChanged:[{type:t.Output}],onMaxTagsReached:[{type:t.Output}],onNoOptionsMatch:[{type:t.Output}]},e}(),l=function(){function e(){}return e.forRoot=function(){return{ngModule:e,providers:[]}},e.decorators=[{type:t.NgModule,args:[{declarations:[r],imports:[n.CommonModule,a.FormsModule,o.NgbTypeaheadModule],exports:[r]}]}],e}();e.TagsInputService=i,e.TagsInputComponent=r,e.TagsInputModule=l,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ngx-tags-input.umd.min.js.map